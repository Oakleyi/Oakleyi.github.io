{"meta":{"title":"Aabigale's blog","subtitle":"","description":"","author":"Aabigale","url":"www.aabigale.top","root":"/"},"pages":[{"title":"","date":"2020-04-03T08:23:58.434Z","updated":"2020-04-03T08:23:58.434Z","comments":true,"path":"about/index.html","permalink":"www.aabigale.top/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-04-03T09:01:13.200Z","updated":"2020-04-03T09:01:13.200Z","comments":false,"path":"categories/index.html","permalink":"www.aabigale.top/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-04-03T08:24:18.028Z","updated":"2020-04-03T08:24:18.028Z","comments":false,"path":"tags/index.html","permalink":"www.aabigale.top/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"机器学习","slug":"机器学习","date":"2020-07-28T01:22:53.937Z","updated":"2020-08-01T12:09:47.180Z","comments":true,"path":"2020/07/28/机器学习/","link":"","permalink":"www.aabigale.top/2020/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"机器学习","text":"机器学习 引言什么是机器学习？1计算机程序从经验E中学习，解决某一任务T，进行某一性能度量P，通过P测定在T上的表现因经验E而提高。 什么是监督学习？1给算法一个数据集，其中包含了正确答案，算法的目的是给出更多的正确答案 什么是无监督学习？123数据集是没有任何标签、都具有相同标签或都没标签，不知道该如何使用该数据集。无监督学习将它分成不同的簇（类）--聚类算法找出数据结构--鸡尾酒聚会算法 单变量线性回归模型表示代价函数代价函数的直观理解梯度下降梯度下降的直观理解梯度下降的线性回归线性回归的梯度下降线性代数回顾矩阵和向量加法和标量乘法矩阵向量乘法矩阵乘法矩阵乘法的性质逆、转置多变量线性回归(Linear Regression with Multiple Variables)多维特征多变量梯度下降梯度下降法实践1-特征缩放梯度下降法实践2-学习率特征和多项式回归正规方程Octave教程(Octave Tutorial)基本操作移动数据计算数据绘图数据控制语句：for，while，if语句向量化 88工作和提交的编程练习逻辑回归(Logistic Regression)分类问题假说表示判定边界代价函数简化的成本函数和梯度下降高级优化多类别分类：一对多第七讲 正则化问题过拟合的问题什么是过度拟合例1 预测房价&lt;线性回归&gt;训练集如下 7.1 7.2 123上图中的第一个图片：该算法没有很好的拟合训练集，称为欠拟合。上图中的第二个图片：与训练集很好的拟合上图中的第三个图片：该算法似乎很好的拟合训练集，但是上下波动，不是预测房价的一个很好的模型，这个称为过度拟合。&lt;另一种说法是该算法具有高方差&gt; 过度拟合问题将在变量过多的时候出现，但是代价函数可能非常接近0，或者恰好为 0。不能很好地应用到新样本 例2 分类问题例题训练集 7.3 7.4 123上图中的第一个图片：这个算法也没有很好的拟合训练集，称为欠拟合。上图中的第二个图片：与训练集很好的拟合上图中的第三个图片：该算法似乎很好的拟合训练集，但是上下波动，不是预测房价的一个很好的模型，这个称为过度拟合。&lt;另一种说法是该算法具有高方差&gt; 过拟合问题发生时解决方法 减少特征变量。&lt;模型选择算法&gt; 正则化。 保留所有的特征，但是减少量级或减少参数的大小。 代价函数例1 在上图中可以看出第二个曲线图过拟合了，不能很好的泛化。 解决方法：加入惩罚项使得θ_3 和 θ__4都非常小，将会得到一个更简单的假设模型 例2 房屋预测模型1234特征：x_1、x_2、......、x_100参数：θ0、θ1、θ2、......、θ100但是不知道参数中哪些是高阶项 此时解决过拟合问题的方法是：通过修改代价函数来缩小所有的参数 1234在代价函数后面添加一个额外的正则化项，来缩小每一个参数。tip: 1、添加的正则项从θ0、θ1求和在实际过程中没什么区别 2、正则参数的作用：控制目标函数的第一项和目标函数的第二项、正 则化目标之间的平衡关系 正则化线性回归梯度下降正则化线性回归优化目标 7.6 用梯度下降法去最小化最初的代价函数，即下图算法 7.7 处理 0 的原因是对于正则化线性回归，惩罚对象是 θ1、θ2、……、θn，没有惩罚 θ0。 对正则化代价函数 J(θ) 用梯度下降法进行最小化 7.8 对上式简化得到图7.9 7.9 由图7.9不难看出正则化线性回归的梯度下降算法的变化在于，每次都在原有算法更新规则的基础上令值减少了一个额外的值，往零更进一步。 正规方程方法如图7.10所示 7.10 12tip: 1、因为X是 m*（n+1）的矩阵，所以需要对进行转置才能与y进行相乘。 2、图中的矩阵尺寸为（ n + 1 ）*（ n + 1 ） 正则化逻辑回归模型梯度下降正则化逻辑回归模型优化目标 7.11 添加的正则项的作用：惩罚参数θ1、θ2、……、θn，防止他们过大，产生的效果就是防止该算法过度拟合。 7.7 对正则化代价函数 J(θ) 用梯度下降法进行最小化 另一种高级优化算法1需要自己定义一个 costFunction 函数，这个函数以参数向量 theta 作为输入。&lt;参数从θ0、θ1、θ2、......、θn&gt; 正则化线性回归正则化的逻辑回归模型第八讲 神经网络非线性回归———阐述研究神经网络目的&lt;例题引入&gt;例1 监督学习分类问题训练集如图所示 8.1 若用 logistic 回归函数，要构造一个包含很多非线性项的 logistic 回归函数，在本例中特征只有两项，当把特征值的所有组合都包含在多项式中，确实能能得到一个不错的结果。 但有趣的机器学习问题特征值往往不止2项。这时这种方法计算量会巨大 神经元和大脑模型表示1模型表示2特征和直观理解1样本和直观理解2多类分类 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数学建模比赛","slug":"数学建模比赛","date":"2020-07-25T13:08:59.797Z","updated":"2020-07-25T13:15:06.542Z","comments":true,"path":"2020/07/25/数学建模比赛/","link":"","permalink":"www.aabigale.top/2020/07/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%AF%94%E8%B5%9B/","excerpt":"数学建模比赛","text":"数学建模比赛 评价类模型评价类模型——层次分析法（AHP）主要用于解决评价类问题（例如：选择哪种方案最好、哪位运动员或者员工表现的更优秀。） 使用打分法解决评价类问题完成下列表格即可 指标权重 方案1 方案2 …… 指标1 指标2 指标3 …… 解决评价类问题，首先要想到以下三个问题： 评价的目标是什么？ 达到目的有哪几种可选方案？ 评价的准则或者说指标是什么？（根据什么来评价好坏）背景资料、常识以及网上搜集参考资料。&lt;优先选择知网、万方、百度学术、谷歌学术，借鉴已发表的论文&gt;。推荐一个网站虫部落 一道引出层次分析的例题​ 高考后，小明想去旅游。爱查阅攻略后，他初步选择了苏杭、北戴河和桂林三地之一作为目标景点。请你确定评价指标、形成评价体系来为小明同学选择最佳方案。 加入查阅资料后选择了以下五个指标：景色、旅游花费、居住环境、饮食状况、交通便利程度 填写权重表格 指标权重 苏杭 北戴河 桂林 景色 花费 居住 饮食 交通 填写表格 分而治之思想 12问题：一次性考虑多个指标之间的关系，往往考虑不周解决方法：两个两个指标进行比较，最终根据两两比较的结果来推算权重 根据下表标度填写表格 标度 含义(重要性有时候解释为满意度) 1 表示两个因素相比，具有同样重要性 3 表示两个因素相比，一个因素比另一个因素稍微重要 5 表示两个因素相比，一个因素比另一个因素明显重要 7 表示两个因素相比，一个因素比另一个因素强烈重要 9 表示两个因素相比，一个因素比另一个因素极端重要 2,4,6,8 上述两相邻判断的中值 倒数 A和B相比如果标度为3，那么B和A相比就是1/3 判断矩阵 景色 花费 居住 饮食 交通 景色 1 1/2 4 3 3 花费 2 1 7 5 5 居住 1/4 1/7 1 1/2 1/3 饮食 1/3 1/5 2 1 1 交通 1/3 1/5 3 1 1 该方阵有如下特点 aij 表示的意义是，与指标j相比，i的重要程度 i = j 时，两指标相同，同等重要，对应对角线 aij &gt; 0 且满足aij * aji = 1 （正互反矩阵） 重复使用判断矩阵得到以下矩阵 花费 苏杭 北戴河 桂林 苏杭 1 1/3 1/8 北戴河 3 1 1/4 桂林 8 3 1 居住 苏杭 北戴河 桂林 苏杭 1 1 3 北戴河 1 1 3 桂林 1/3 1/3 1 饮食 苏杭 北戴河 桂林 苏杭 1 3 4 北戴河 1/3 1 1 桂林 1/4 1 1 交通 苏杭 北戴河 桂林 苏杭 1 1 1/4 北戴河 1 1 1/4 桂林 4 4 1 景色 苏杭 北戴河 桂林 苏杭 1 2 4 北戴河 1/2 1 2 桂林 1/4 1/2 1 一个可能出现问题的地方 假如是该矩阵 景色 苏杭 北戴河 桂林 苏杭 1 2 1 北戴河 1/2 1 2 桂林 1 1/2 1 12345设苏杭 = A ，北戴河 = B，桂林 = C苏杭比北戴河景色好一点 A&gt;B苏杭和桂林景色一样好 A=B北戴河比桂林景色好一点 B&gt;C出现了矛盾之处（不一致现象） * **一致矩阵的特点：各行（各例）之间成倍数关系，在使用判断矩阵求权重之前，必须对其进行一致性检验** * 一致性检验 引理：n阶正互反矩阵A为一致行矩阵时当且仅当最大特征值a = n，且当正互反矩阵A非一致时，一定满足 a&gt;n 。**判断矩阵越不一致时，最大特征值与n相差就越大** 证明过程： 步骤： * 计算一致性指标CI，CI= （a-n）/（n-1） * 查找对应的平均随机一致性指标 RI | n | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | | RI | 0 | 0 | 0.52 | 0.89 | 1.12 | 1.26 | 1.36 | 1.41 | 1.46 | 1.49 | 1.52 | 1.54 | 1.56 | 1.58 | 1.59 | * 计算一致性比例CR，CR = CI/RI **如果CR &lt; 0.1，则可认为判断矩阵的一致性可以接受；否则需要对判断矩阵进行修正** 计算权重 一致矩阵计算 权重就景色而言，苏杭的重要性如果是1，那么北戴河的重要性就是1/2，桂林的重要性就是1/4。 景色 苏杭 北戴河 桂林 苏杭 1 2 4 北戴河 1/2 1 2 桂林 1/4 1/2 1 权重一定要进行归一化处理 ​ 苏杭 = 1 / (1+0.5+0.25) 北戴河 = 0.5 / (1+0.5+0.25) ​ 桂林 = 0.25 / (1+0.5+0.25 算术平均法 景色 苏杭 北戴河 桂林 苏杭 1 2 5 北戴河 1/2 1 2 桂林 1/5 1/2 1 分别使用一二三列的数据，再求平均权重 将判断矩阵按照列归一化 景色 苏杭 北戴河 桂林 苏杭 0.5882 0.5714 0.625 北戴河 0.2941 0.2857 0.25 桂林 0.1177 0.1429 0.125 将归一化的各列相加 未归一化的权重 苏杭 0.5882+0.5714+0.625 = 1.7846 北戴河 0.2941+0.2857+0.25 = 0.8298 桂林 0.1177+0.1429+0.125 = 0.3856 将相加后的向量中的每一个袁初一n即可得到权重向量 权重 苏杭 1.7846 / 3 = 0.5949 北戴河 0.8298 /3 = 0.2766 桂林 0.3856 / 3 = 0.1285 几何平均法 特征值法 填写表格 指标权重 苏杭 北戴河 桂林 景色 0.2636 0.5954 0.27644 0.1283 花费 0.4758 0.0819 0.2363 0.6817 居住 0.0538 0.4286 0.4286 0.1429 饮食 0.0981 0.6337 0.1919 0.1744 交通 0.1087 0.1667 0.1667 0.6667 苏杭得分：0.5954 * 0.2636 + 0.0819 * 0.4758 + 0.4286 * 0.538 + 0.6337 * 0.0981 + 0.1667 * 0.1087 = 0.299 北戴河得分：0.245 桂林得分：0.455 小结——层次分析法的步骤 分析系统中各因素之间的关系，建立关系的递阶层次结构需放入论文，推荐亿图图示软件画结构图 目标层 准则层 方案层 构造判断矩阵(直接自己写) 计算权重：有三种方法都要计算 TOPSIS 法 （优劣解距离法）插值与拟合模型相关性模型回归模型图论模型分类问题聚类模型时间序列模型预测模型降维模型 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Python深度学习-----Python机器学习应用","slug":"Python深度学习-----Python机器学习应用","date":"2020-07-13T02:36:58.976Z","updated":"2020-07-25T13:15:06.536Z","comments":true,"path":"2020/07/13/Python深度学习-----Python机器学习应用/","link":"","permalink":"www.aabigale.top/2020/07/13/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-----Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%94%E7%94%A8/","excerpt":"Python深度学习—–Python机器学习应用","text":"Python深度学习—–Python机器学习应用 书籍推荐：《 机器学习 》 - 周志华，《 PRML》 - Bishop ， 课程推荐：《 Machine Learning 》- Andrew Ng ，《 CS231n 》 - Fei-Fei Li 课程导学 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Linux C  C++ 后端应届工程师","slug":"Linux C  C++ 后端应届工程师","date":"2020-06-12T01:37:31.872Z","updated":"2020-07-25T13:15:06.532Z","comments":true,"path":"2020/06/12/Linux C  C++ 后端应届工程师/","link":"","permalink":"www.aabigale.top/2020/06/12/Linux%20C%20%20C++%20%E5%90%8E%E7%AB%AF%E5%BA%94%E5%B1%8A%E5%B7%A5%E7%A8%8B%E5%B8%88/","excerpt":"Linux C / C++ 后端应届工程师","text":"Linux C / C++ 后端应届工程师 基础知识以及 Linux 入门第一阶段：2~3个月扎实算法和数据结构，刷LeetCode，刷出最优解扎实C语言：基本数据结构，指针：指针、指针步长、为啥能够通过指针找到对应数据、函数指针第二阶段：2~3个月OO思想，用函数指针去搞定OO思想Linux入门，几个常用命令，调试手段等Linux c编程入门，多线程、多进程、内存管理、网络编程等等，Unix环境高级编程第三阶段：2~3个月学会封装思维，接口思维，多态思维等等C++入门，掌握C with class，C++的OOP,两者的区别以及联系使用Linux C++将第二阶段的项目重写一遍第二大阶段：造轮子的能力第一阶段：2~3个月基础版高并发服务器，参考libevent、muduo等多线程、多进程、以及IO多路复用线程池、内存池的实现，为服务器增加组件日志组件消息队列–做限流削峰第二阶段：系统学习操作系统与分布式系统1、编写小型操作系统：参考清华大学操作系统课程的ucore 扎扎实实2~3个月a)深入理解计算机系统（链接、装载那必须好好看）2、编写分布式系统：参考资料MIT的6.824课程，刷raft的论文，扎实搞2~3个月第三大阶段：培养阅读源码的能力第一阶段：3~4个月，（需要学会利用已有资源，达到一个加速效果，比如一些博客和书籍）推荐Redis、Nginx、Rocksdb等等 学会使用，以及懂源码原理 这里推荐一个群：568892619 在这个阶段，顺便实现协程 需要关注的几个特性：栈自动扩容、HOOK机制等等 第二阶段：1个月Linux内核相关特性进程调度过程、线程与进程的内核实现区别、内存管理（伙伴系统与slab系统）进程和内存相关数据结构内核slab链表细节，常见的slab子项（例如task_struck，file_struct等等）五种IO模型，以及等待队列的意义select、poll、epoll之间的区别，以及内核实现第四大阶段： 到这里，如果进展顺利的话，大概刚刚才到大三总结复习已有知识，查漏补缺完善高并发服务器，改为分布式服务器学会使用几个RPC组件，学会protobuf的使用等等学习设计模式的思维学习架构思维： 推荐：《大数据日知录》单机-&gt;多机分层思维高级数据结构知识的掌握：10~20天红黑树（记住特性即可）B-tree、LSM tree、跳表、布隆过滤器等等去整理一下大厂常见面试题，刷好面经，整理好简历，一直到大三的寒假，开始投递简历，大三下出去实习，以现在的实力，只要进了面试，基本上不会被刷，去名企。 实习到7、8月份左右，出来，开始参加秋招，把以前的知识再好好复习一遍，即将开启offer收割之路 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Java 数据结构和算法","slug":"Java 数据结构和算法","date":"2020-05-09T09:13:24.715Z","updated":"2020-07-25T13:15:06.520Z","comments":true,"path":"2020/05/09/Java 数据结构和算法/","link":"","permalink":"www.aabigale.top/2020/05/09/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","excerpt":"Java 数据结构和算法","text":"Java 数据结构和算法 稀疏数组单向队列环形队列单向链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2020-05-09T07:55:58.571Z","updated":"2020-07-25T13:15:06.557Z","comments":true,"path":"2020/05/09/计算机组成原理/","link":"","permalink":"www.aabigale.top/2020/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","excerpt":"计算机组成原理","text":"计算机组成原理 讲授内容： 123基本部件的结构与组织方式基本运算的操作原理基本部件和单元的设计思想 推荐阅读教材：《数字设计和计算机体系结构》 计算机组成原理之机器计算机系统的基本概念 &lt;第一章&gt;计算机系统简介 计算机的软硬件概念 计算机系统 软件 系统软件：用来管理整个计算机系统 语言处理程序、操作系统、服务性程序、数据管理系统、网络软件 应用软件：按任务需要编制成的各种程序 硬件 计算机系统的层次结构 高级语言 虚拟机器 M4 用编译语言翻译成汇编语言程序 汇编语言 虚拟机器 M3 用汇编语言翻译成机器语言程序 操作系统 虚拟机器 M2 用机器语言解释操作系统 机器语言 实际机器 M1 用微指令解释机器语言 微指令系统 微程序机器 M0 有硬件直接执行微指令 计算机的组成和计算机的体系结构 计算机体系结构：机器语言程序员所见到的计算机系统的属性 计算机组成：实现计算机体系结构所体现的属性 （具体指令的实现） 计算机的基本组成 冯若依曼计算机的特点 计算机有五大部件组成：运算器、控制器、存储器、输入设备、输出设备 指令和数据以同等地位存于存储器，可按地址寻址 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 冯若依曼计算机硬件框图 计算机硬件框图 以存储器为中心的计算机硬件框图 现代计算机硬件框图 主机 CPU 运算器 ALU 控制器 CU 存储器：主存、辅存 I/O设备 输入设备 输出设备 现代计算机硬件框图 1234系统复杂性管理的方法-2（3'Y） - 层次化：将被设计的系统划分为多个模块或子模块 - 模块化：有明确定义的功能和接口 - 规则性：模块更容易被重用 用计算机解决问题的工作步骤 上机前的准备 建立数学模型 确定计算方法 编写解题步骤 存储器的基本组成 ​ MAR：存储器地址寄存器（保存了存储单元的地址或编号）反映存储单元的个数 MDR：存储器数据寄存器，反映存储字长 运算器的基本结构和操作过程 加法操作过程 减法操作过程 乘法操作过程 除法操作过程 控制器的基本结构 功能 解释指令 保证指令有序执行 组成 主机完成一条指令的过程（以取数指令为例） 取指令：PC –&gt; MAR –&gt; M –&gt; MDR –&gt; IR , (PC) + 1 –&gt; PC 分析指令：OP(IR) –&gt; CU 执行指令：Ad(IR) –&gt; MAR –&gt; M –&gt;MDR –&gt;ACC 计算机硬件的主要技术指标总线 &lt;第三章&gt;存储器 &lt;第四章&gt;输入输出系统&lt;第五章&gt;计算机组成原理之数字计算机中数的表示计算机的运算方法和运算器 &lt;第六章&gt;计算机组成原理之CPU指令系统 &lt;第七章&gt;CPU的结构和功能 &lt;第八章&gt;控制单元 &lt;第九章&gt;操作命令的分析控制单元的功能控制单元的设计 &lt;第十章&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据库系统概述三","slug":"数据库系统概述三","date":"2020-04-23T03:16:12.370Z","updated":"2020-07-25T13:15:06.553Z","comments":true,"path":"2020/04/23/数据库系统概述三/","link":"","permalink":"www.aabigale.top/2020/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E4%B8%89/","excerpt":"数据库系统概述三","text":"数据库系统概述三 数据库管理系统的实现技术第七章 数据库存储与索引技术第十七讲—数据库物理存储第十八讲—数据库索引技术第八章 数据库基本操作的实现算法第十九讲—数据库查询实现算法I一趟扫描算法第二十讲—数据库查询实现算法II二趟扫描算法第九章 数据库查询优化与查询实现第二十一讲—数据库查询优化技术第十章 数据库事务处理第二十二讲—数据库事务处理技术-并发控制第二十三讲—数据库事务处理技术-并发控制课程总结 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Java学习之高级篇","slug":"Java学习之高级篇","date":"2020-04-17T12:18:51.793Z","updated":"2020-04-18T02:54:06.193Z","comments":true,"path":"2020/04/17/Java学习之高级篇/","link":"","permalink":"www.aabigale.top/2020/04/17/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%AF%87/","excerpt":"高级篇","text":"高级篇 新技术Java 9 Jigsaw Jshell Reactive Streams Java 10 局部变量类型推断 G1的并行Full GC ThreadLocal握手机制 Java 11 ZGC Epsilon 增强var Java 12 Switch 表达式 Java 13 Text Blocks Dynamic CDS Archives Java 14 Java打包工具 更有价值的NullPointerException record类型 Spring 5 响应式编程 Spring Boot 2.0 http/2 http/3 性能优化使用单例使用Future模式使用线程池选择就绪减少上下文切换减少锁粒度数据压缩结果缓存Stream并行流GC调优JVM内存分配调优SQL调优线上问题分析dump 线程Dump 内存Dump gc情况 dump获取及分析工具 jstack jstat jmap jhat Arthas dump分析死锁dump分析内存泄露自己编写各种outofmemory，stackoverflow程序 HeapOutOfMemory Young OutOfMemory MethodArea OutOfMemory ConstantPool OutOfMemory DirectMemory OutOfMemory Stack OutOfMemory Stack OverFlow Arthas jvm相关 class/classloader相关 monitor/watch/trace相关 options 管道 后台异步任务 常见问题解决思路 内存溢出 线程死锁 类加载冲突 load飙高 CPU利用率飙高 慢SQL 使用工具尝试解决以下问题，并写下总结 当一个Java程序响应很慢时如何查找问题 当一个Java程序频繁FullGC时如何解决问题 如何查看垃圾回收日志 当一个Java应用发生OutOfMemory时该如何解决 如何判断是否出现死锁 如何判断是否存在内存泄露 使用Arthas快速排查Spring Boot应用404/401问题 使用Arthas排查线上应用日志打满问题 利用Arthas排查Spring Boot应用NoSuchMethodError 编译原理知识编译与反编译Java代码的编译与反编译Java的反编译工具 javap jad CRF 即时编译器 编译器优化 操作系统知识Linux的常用命令 find、grep、ps、cp、move、tar、head、tail、netstat、lsof、tree、wget、curl、ping、ssh、echo、free、top 进程间通信服务器性能指标 load CPU利用率 内存使用情况 qps rt 进程同步 生产者消费者问题 哲学家就餐问题 读者写者问题 缓冲区溢出分段和分页虚拟内存与主存虚拟内存管理换页算法数据库知识MySql 执行引擎MySQL 执行计划 如何查看执行计划 如何根据执行计划进行SQL优化 索引 Hash索引&amp;B树索引 普通索引&amp;唯一索引 聚集索引&amp;非聚集索引 覆盖索引 最左前缀原则 索引下推 索引失效 回表SQL优化数据库事务和隔离级别 事务的ACID 事务的隔离级别与读现象 事务能不能实现锁的功能 编码方式 utf8 utf8mb4 为什么不要在数据库中使用utf8编码 行数统计 count(1)、count(*)、count(字段)的区别 为什么建议使用count(*) 数据库锁 共享锁、排它锁 行锁、表锁 乐观锁、悲观锁 使用数据库锁实现乐观锁 Gap Lock、Next-Key Lock 连接 内连接 左连接 右连接 数据库主备搭建log binlog redolog 内存数据库 h2 分库分表读写分离常用的nosql数据库 redis memcached 分别使用数据库锁、NoSql实现分布式锁性能调优数据库连接池数据结构与算法知识简单的数据结构 栈 队列 链表 数组 哈希表 栈和队列的相同和不同之处 栈通常采用的两种存储结构 两个栈实现队列，和两个队列实现栈 树 二叉树 字典树 平衡树 排序树 B树 B+树 R树 多路树 红黑树 堆 大根堆 小根堆 图 有向图 无向图 拓扑 稳定的排序算法 冒泡排序 插入排序 鸡尾酒排序 桶排序 计数排序 归并排序 原地归并排序 二叉排序树排序 鸽巢排序 基数排序 侏儒排序 图书馆排序 块排序 不稳定的排序算法 选择排序 希尔排序 Clover排序算法 梳排序 堆排序 平滑排序 快速排序 内省排序 耐心排序 各种排序算法和时间复杂度深度优先和广度优先搜索全排列贪心算法KMP算法hash算法海量数据处理 分治 hash映射 堆排序 双层桶划分 Bloom Filter bitmap 数据库索引 mapreduce等。 大数据知识搜索 Solr Lucene ElasticSearch 流式计算 Storm Spark Flink Hadoop，离线计算 HDFS MapReduce 分布式日志收集 flume kafka logstash 数据挖掘 mahout 网络安全知识XSS XSS的防御 CSRF注入攻击 SQL注入 XML注入 CRLF注入 文件上传漏洞加密与解密 对称加密 非对称加密 哈希算法 加盐哈希算法 加密算法 MD5，SHA1、DES、AES、RSA、DSA 彩虹表DDOS攻击DOS攻击DDOS攻击memcached为什么可以导致DDos攻击什么是反射型DDoS如何通过Hash碰撞进行DOS攻击SSL、TLS，HTTPS脱库、洗库、撞库 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Java学习之进阶篇","slug":"Java学习之进阶篇","date":"2020-04-17T12:04:26.505Z","updated":"2020-04-18T02:54:06.189Z","comments":true,"path":"2020/04/17/Java学习之进阶篇/","link":"","permalink":"www.aabigale.top/2020/04/17/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%AF%87/","excerpt":"进阶篇","text":"进阶篇 Java底层知识字节码class文件格式CAFEBABE位运算用位运算实现加、减、乘、除、取余设计模式设计模式的六大原则 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 创建型设计模式 单例模式 抽象工厂模式 建造者模式 工厂模式 原型模式 结构型设计模式 适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式 行为型设计模式 模版方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 责任链模式 访问者模式 单例的七种写法 懒汉——线程不安全 懒汉——线程安全 饿汉 饿汉——变种 静态内部类 枚举 双重校验锁 为什么推荐使用枚举实现单例？三种工厂模式的区别及联系 简单工厂、工厂方法、模板工厂 会使用常用设计模式 工厂模式 适配器模式 策略模式 模板方法模式 观察者模式 外观模式 代理模式 不用synchronized和lock，实现线程安全的单例模式nio和reactor设计模式Spring中用到了哪些设计模式网络编程知识常用协议 tcp、udp、http、https 用Java实现FTP、SMTP协议 OSI七层模型 每一层的主要协议 TCP/UDP 三次握手与四次关闭 流量控制和拥塞控制 tcp粘包与拆包 TCP/IP IPV4 IPV6 HTTP http/1.0 http/1.1 http/2之间的区别 http和https的区别 http中 get和post区别 常见的web请求返回的状态码 404、302、301、500分别代表什么 用Java写一个简单的静态文件的HTTP服务器 http/2Java RMI，Socket，HttpClientcookie 与 session cookie被禁用，如何实现session 了解nginx和apache服务器的特性并搭建一个对应的服务器进程间通讯的方式什么是CDN？如果实现？DNS？ 什么是DNS 记录类型:A记录、CNAME记录、AAAA记录等 域名解析 根域名服务器 DNS污染 DNS劫持 公共DNS：114 DNS、Google DNS、OpenDNS 反向代理 正向代理 反向代理 反向代理服务器 框架知识Servlet 生命周期 线程安全问题 filter和listener web.xml中常用配置及作用 Hibernate 什么是OR Mapping Hibernate的缓存机制 Hibernate的懒加载 Hibernate/Ibatis/MyBatis之间的区别 MyBatis Mybatis缓存机制 #{}和${}的区别 mapper中传递多个参数 Mybatis动态sql Mybatis的延迟加载 Spring Bean的初始化 AOP原理 实现Spring的IOC spring四种依赖注入方式 Spring MVC 什么是MVC Spring mvc与Struts mvc的区别 Spring Boot Spring Boot 2.0 起步依赖 自动配置 Spring Boot的starter原理 自己实现一个starter 为什么Spring Boot可以通过main启动web项目 Spring SecuritySpring Cloud 服务发现与注册：Eureka、Zookeeper、Consul 负载均衡：Feign、Spring Cloud Loadbalance 服务配置：Spring Cloud Config 服务限流与熔断：Hystrix 服务链路追踪：Dapper 服务网关、安全、消息 应用服务器知识JBosstomcatjettyWeblogic工具git &amp; svnmaven &amp; gradlegit技巧 分支合并 冲突解决 提交回滚 maven技巧 依赖树 依赖仲裁 Intellij IDEA 常用插件：Maven Helper、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat、Lombok plugin、.ignore、Mybatis plugin document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Java学习之底层篇","slug":"Java学习之底层篇","date":"2020-04-17T11:53:08.718Z","updated":"2020-04-18T02:54:06.181Z","comments":true,"path":"2020/04/17/Java学习之底层篇/","link":"","permalink":"www.aabigale.top/2020/04/17/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BA%95%E5%B1%82%E7%AF%87/","excerpt":"底层篇","text":"底层篇 JVMJVM内存结构 运行时数据区 运行时数据区哪些是线程独享 堆和栈区别 方法区在不同版本JDK中的位置 堆外内存 TLAB Java中的对象一定在堆上分配吗？ 垃圾回收 GC算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收 GC参数 对象存活的判定 垃圾收集器（CMS、G1、ZGC、Epsilon） JVM参数及调优 -Xmx -Xmn -Xms -Xss -XX:SurvivorRatio -XX:PermSize -XX:MaxPermSize -XX:MaxTenuringThreshold Java对象模型 oop-klass 对象头 HotSpot 即时编译器 编译优化 Java内存模型 计算机内存模型 缓存一致性 MESI协议 可见性 原子性 顺序性 happens-before as-if-serial 内存屏障 synchronized volatile final 锁 虚拟机性能监控与故障处理工具 jps jstack jmap jstat jconsole jinfo jhat javap btrace TProfiler jlink Arthas 类加载机制 classLoader 类加载过程是线程安全的吗？ 类加载过程 双亲委派（破坏双亲委派） 模块化（jboss modules、osgi、jigsaw） 打包工具 jar jlink jpackage 编译与反编译 什么是编译 什么是反编译 编译工具：javac 反编译工具：javap 、jad 、CRF JIT JIT优化（逃逸分析、栈上分配、标量替换、锁优化） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据库系统概述二","slug":"数据库系统概述二","date":"2020-04-10T08:26:01.025Z","updated":"2020-04-24T08:52:03.834Z","comments":true,"path":"2020/04/10/数据库系统概述二/","link":"","permalink":"www.aabigale.top/2020/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E4%BA%8C/","excerpt":"数据库系统概述二","text":"数据库系统概述二 数据建模与数据库设计第五章 数据建模与数据库设计第十一讲—数据建模之思想与方法第十二讲—数据建模之工程化方法及案例分析第十三讲—数据库设计过程1234本讲重难点：* 理解数据库设计的四个过程 * 理解不正确数据库设计引发的问题，为数据库理论的学习奠定问题基础 * 理解不正确数据库设计引发的问题，提升数据建模与数据库设计能力 数据库设计过程与方法 数据库设计的四个过程 需求分析 —————— 收集需求和理解需求，”源” 概念数据库设计 ———– 建立概念模型。”E-R图 / IDEF1x图” 逻辑数据库设计 ———– 建立逻辑模型，“关系模式” 包括全局模式和用户模式(外模式) 物理数据库设计 ———– 建立物理模型，“Create Table” 包括物理数据组织等，依赖于具体的DBMS 需求分析 了解部门-岗位 对每一岗位，收 集“源”—形成 源表 理解每一“源” –源的属性构成 –源的处理规则 –源的属性处理规则 形成并提交需求 分析报告 概念数据库设计 依据需求分析报告 识别实体与联系 局部 E-R 模式设计 需求分析的”源” → 确定局部结构范围 → 实体定义 → 联系定义 → 属性分配 → 全局 E-R 模式设计 全局 E-R 模式设计 局部E-R模式 → 确定公共实体类型 → 合并两个局部E-R模式 → 检查并消除冲突 → 还有未合并的 局部模式？&lt; 有的话 继续合并 &gt; → 全局E-R模式优化 消除冲突 属性冲突 –属性域的冲突：属性的类型、取值范围不同 *如不同学校的学号编码方式不同 * –属性取值单位冲突 如重量分别采用磅、千克 结构冲突 –同一对象在不同应用中的抽象不同 *如职工在某应用中是实体，在另一应用中则抽象为属性 * –同一实体在不同E-R图中属性组成不同 –实体之间的联系在不同E-R图中呈现不同的类 命名冲突 –同名异义：不同意义的对象具有相同的名字 –异名同义：同一意义的对象具有不同的名字 * 结构冲突 * 命名冲突 * 绘制E-R图 / IDEF1x图用图表达业务规则 定义实体、联系及实体的属性构成 形成并提交概念 数据库设计报告 E-R图/IDEF1X向关系模式的转换 不正确数据库设计引发的问题及其解决第六章 数据库设计理论第十四讲—函数依赖及其公理定理第十五讲—关系模式设计之规范化形式第十六讲—模式分解存在的问题及解决 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"JAVA实训作业","slug":"JAVA实训作业","date":"2020-04-09T07:59:31.340Z","updated":"2020-04-12T05:46:52.794Z","comments":true,"path":"2020/04/09/JAVA实训作业/","link":"","permalink":"www.aabigale.top/2020/04/09/JAVA%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/","excerpt":"JAVA实训作业","text":"JAVA实训作业 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"前端之CSS","slug":"前端之CSS","date":"2020-04-07T06:02:28.960Z","updated":"2020-04-28T09:54:57.043Z","comments":true,"path":"2020/04/07/前端之CSS/","link":"","permalink":"www.aabigale.top/2020/04/07/%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/","excerpt":"前端之CSS","text":"前端之CSS CSS 和 文档选择器常用选择器 元素选择器 作用：根据标签名选中指定元素 语法：标签名{ } 例子：p{ } h1{ } div{ } id 选择器 作用：根据元素的id的属性值选中一个元素 语法：#id属性值{ } 例子：#box{ } #red{ } 类选择器 作用： 根据元素的class属性值选中一组元素 class 可以同时为一个元素指定多个 class 属性 语法：.class属性值{ } 例子：.blue{ } 通配选择器 作用选中页面中的所有元素 语法：*{ } 复合选择器 交集选择器 作用：选中同时复合多个条件的元素 语法：选择器1选择器2…….选择器n{ } 注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头 并集选择器 作用：同时选中多个选择器对应的元素 语法：选择器1,选择器2,选择器3,……,选择器n{ } 关系选择器属性选择器伪类选择器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"在vscode中配置Java环境","slug":"在vscode中配置Java环境","date":"2020-04-07T05:19:19.431Z","updated":"2020-04-08T11:53:19.819Z","comments":true,"path":"2020/04/07/在vscode中配置Java环境/","link":"","permalink":"www.aabigale.top/2020/04/07/%E5%9C%A8vscode%E4%B8%AD%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83/","excerpt":"在vscode中配置Java环境","text":"在vscode中配置Java环境 下载官网下载 使用配置中文 点击旁边的 Extensions 搜索框编辑 Chinese 下载 Chinese ( Simplified ) 更换主题​ 可以看自己喜好 下载关于编辑 Java 的插件​ 便于编辑而安装的插件 12345Beautify：代码高亮Terminal：直接唤起终端Project Manager：多个项目切换Auto Close Tag：标签自动闭合Eclipse Keymap：可以通过一些快捷键更方便地编写Java 配置 Java 环境而安装的插件 1234Language Support for Java(TM) by Red Hat 运行 Java 代码的Debugger for Java 调试 Java 程序Java Test Runner 测试 Java 程序Maven for Java Java环境下构建应用程序的软件 设置工作环境 点击菜单 File( 文件 ) –&gt; Save Workspace As····( 将工作区另存为)···· 将新建的 ( 文件名 ) 文件添加至工作区 新建 Java 项目 在工作区点击菜单栏 View ( 查看 ) –&gt; command Palette ( 命令面板) 输入Java，选择Java : Create Java Project，新建Java项目 在弹出的框中，选择工作空间文件夹 接着输入项目名称，回车 会自动生成一段打印hello Java代码 编译运行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"html","slug":"html","date":"2020-04-06T13:59:36.547Z","updated":"2020-04-08T11:53:19.803Z","comments":true,"path":"2020/04/06/html/","link":"","permalink":"www.aabigale.top/2020/04/06/html/","excerpt":"web前端开发最佳实践","text":"web前端开发最佳实践 高效web前端开发综述web前端开发概述高效web前端开发HTML相关开发最佳实践标准的HTML代码高可读性的HTML积极拥抱HTML5 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"在hexo搭建的博客中引入图片","slug":"在hexo搭建的博客中引入图片","date":"2020-04-06T06:04:08.995Z","updated":"2020-04-06T06:04:37.536Z","comments":true,"path":"2020/04/06/在hexo搭建的博客中引入图片/","link":"","permalink":"www.aabigale.top/2020/04/06/%E5%9C%A8hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87/","excerpt":"","text":"在hexo搭建的博客中引入图片 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Linux","slug":"Linux","date":"2020-04-06T03:15:10.256Z","updated":"2020-04-14T11:33:34.299Z","comments":true,"path":"2020/04/06/Linux/","link":"","permalink":"www.aabigale.top/2020/04/06/Linux/","excerpt":"linux","text":"linux 部署虚拟环境安装 Linux 系统：新手必须掌握的 Linux 命令执行 Linux 命令的格式 1命令名称 [命令参数] [命令对象] &lt;中间用空格隔开&gt; 强大好用的 Shell 通过上下方向键来调取过往执行过的 Linux 命令 命令或参数仅需输入前几位就可以用 tab 键补全 具有强大的批处理脚本 具有实用的环境变量功能 执行帮助文档命令常用系统工作命令 echo 命令 ：用于在终端输出字符串或变量提取后的值，格式为 “ echo [字符串 | $变量] “ date 命令 ：用于显示及设置系统的时间或日期，格式为 “ date [选项] [+指定的格式]” 参数 作用 %t 跳格 [ tab 键] %H 小时（00 ~ 23） %I 小时（00 ~ 12） %M 分钟（00 ~ 59） %S 秒（00 ~ 59） %j 今年中的第几天 reboot 命令：用于重启系统，格式为 reboot poweroff 命令：用于关闭系统，格式为 poweroff wget 命令：用于在终端中下载网络文件，格式为 “ wget [参数] 下载地址” ps 命令：用于查看系统中的进程状态，格式为 “ps [参数]” 参数 作用 -a 显示所有进程（包括其他用户的进程） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 系统状态检测命令 工作目录切换命令文本文件编辑命令文件目录管理命令打包压缩与搜索命令 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2020-04-05T13:51:43.137Z","updated":"2020-04-21T08:18:49.222Z","comments":true,"path":"2020/04/05/数据结构/","link":"","permalink":"www.aabigale.top/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"数据结构","text":"数据结构 数据结构绪论基本概念与术语逻辑结构与物理结构抽象数据结构算法时间复杂度与空间复杂度线性表（list）栈与队列串树图查找排序 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"算法","slug":"算法","date":"2020-04-05T08:58:21.848Z","updated":"2020-04-05T10:05:18.377Z","comments":true,"path":"2020/04/05/算法/","link":"","permalink":"www.aabigale.top/2020/04/05/%E7%AE%97%E6%B3%95/","excerpt":"算法","text":"算法 大整数运算该部分重难点 12* 大整数的运算的算法思想与处理技巧* 大整数进行加、减、乘、除运算的算法框架 计算n！ 当n规模较小 （n&lt;13）123456789#include &lt;stdio.h&gt;main(){ int n,t,k; scanf(\"%d\",&amp;n); t=1; //t为累乘器 for(k=1;k&lt;=n;k++) t*=k; printf(\" %d!=%ld\\n\",n,t);} 当n规模较大123456789101112131415161718192021222324252627282930#include &lt;math.h&gt;#include &lt;stdio.h&gt;int main(){ int j,k,m,n,a[100000]; long g,t; double s; printf(\"Please input an integer: \"); scanf(\"%d\",&amp;n); s=0; for (k=2;k&lt;=n;k++) s+=log10(k); m=(int)s+1;//计算n!后的位数 for (k=1;k&lt;=m;k++) a[k]=0; a[1]=1; g=0;//进位符 for (k=2;k&lt;=n;k++) for (j=1;j&lt;=m;j++) { t=a[j]*k+g; a[j]=t%10; g=t/10; } printf(\"%d!=\",n); for (k=m;k&gt;=1;k--) printf(\"%1d\",a[k]); printf(\"\\n\"); printf(\"m=%d\\n\",m);} 大整数加法 用数组储存，假定每个数组元素存储4位 核心代码： 12345678910void add(int *a, int *b, int *c){ int i; for(i = N - 1; i &gt;= 0; i--) { c[i] = a[i] + b[i] + carry; carry=c[i]/10000; c[i]=c[i]%10000; }} 大整数减法 核心代码： 1234567891011121314void sub(int *a, int *b, int *c) { int i; for(i =N- 1; i &gt;= 0; i--) { c[i] = a[i] - b[i] - borrow; if(c[i] &gt;= 0) borrow = 0; else // 借位 { c[i] = c[i] + 10000; borrow = 1;} }} 大整数乘法 大整数与整数相乘 核心代码： 123456789void mul(int *a, int b, int *c) { int i, tmp, carry = 0; for(i = N - 1; i &gt;= 0; i--) { tmp = a[i] * b + carry; c[i] = tmp % 10000; carry = tmp / 10000; } 大整数与大整数相乘 核心代码： ​ ​ 算法的概念枚举递推递归回溯法动态规划贪心算法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据库系统概述 一","slug":"数据库系统概述 一","date":"2020-04-03T09:02:21.868Z","updated":"2020-06-03T02:52:18.371Z","comments":true,"path":"2020/04/03/数据库系统概述 一/","link":"","permalink":"www.aabigale.top/2020/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%20%E4%B8%80/","excerpt":"数据库系统概述一","text":"数据库系统概述一 数据库基本知识与关系模型第一章 数据库系统的基本概念第一讲—初步认识数据库系统第二讲—数据库系统的结构抽象与演变第二章 关系模型与关系运算第三讲—关系模型之基本概念第四讲—关系模型之关系代数第五讲—关系模型之关系演算数据库语言—SQL第三章 交互式SQL语言及其应用第六讲—SQL语言之概览1234本讲重难点：* SQL-DDL的基本语句：create database，create table* SQL-DML的基本语句：insert，delete，update，select* SQL-select语句的训练：正确表达各种需求 SQL语言概述 SQL 语言提出与发展 SQL 语言的功能概述 SQL语言是集DDL、DML、DCL于一体的数据库语言 SQL语言由9个单词引导操作语句来构成 DDL语句引导词：create，alter，drop DML语句引导词：insert，delete，update，select DCL语句引导词：grant，revoke &lt;安全性控制：授权与撤销授权 交互式SQL→嵌入式SQL→动态SQl等 SQL语言之DML-操作数据库 利用 SQL 语言建立数据库 SQL - DDL 建立数据库：定义数据库和表（使用DDL），向表中追加元祖（使用DML） 创建数据库语句——Create Database 创建Database 数据库 (Database) 是若干具有相互关联关系的Table / Relation 的集合 数据库可以看作是一个集中存放若干 Table 的大型文件 create database 的简单语法形式： create createdatabase database 数据库名; *示例：创建课程学习数据库SCT * create database SCT; 创建关系/表的语句—Create Table create table 简单语法形式 Createtable table表名( 列名数据类型[Primary key Primary key |Unique |Unique][Not Notnull null] [, 列名数据类型[Not Notnull null] , …]) ; “[ ] ”表示其括起的内容可以省略，“| ”表示其隔开的两项可取其一 Primary key:主键约束。每个表只能创建一个主键约束。 Unique:唯一性约束(即候选键)。可以有多个唯一性约束。 Not null: 非空约束。是指该列允许不允许有空值出现，如选择了Notnull表 明该列不允许有空值出现。 语法中的数据类型在SQL标准中有定义 1234示例：定义学生表Student Create Table Student (S#char(8)not null , Snamechar(10), Ssexchar(2), Sageinteger, D#char(2), Sclasschar(6));示例：定义课程表Course Create Table Course (C# char(3) , Cnamechar(12), Choursinteger, Credit float(1), T# char(3)); SQL - DML DML: Data Manipulation Language 向Table中追加新的元组：Insert insert into简单语法形式 insert into 表名[ (列名[, 列名]…] ​ values (值[, 值] , …) ; *values后面值的排列，须与into子句后面的列名排列一致 * 若表名后的所有列名省略，则values后的值的排列，须与该表存储中的 列名排列一致 修改Table中某些元组中的某些属性的值: Update 删除Table中的某些元组: Delete 对Table中的数据进行各种条件的检索: Select 向表中追加元组的值–INSERT INTO 向表中追加元组 insert into简单语法形式 insert into 表名[ (列名[, 列名]…] values values (值[, 值] , …) ; values后面值的排列，须与into子句后面的列名排列一致 若表名后的所有列名省略，则values后的值的排列，须与该表存储中的 列名排列一致 利用SQL语言进行简单查询 单表查询-SELECT-FROM-WHERE Select的简单语法形式 Select 列名[[, 列名] …] From 表名 [ Where 检索条件] ; 语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名 及顺序进行投影显示。 相当于： select语句相当于 Select语句中的select …, from…, where…, 等被称为子句，在以上基本形 式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。 检索条件-SELECT-FROM-WHERE 检索条件的书写 与选择运算的条件con书写一样，只是其逻辑运算符用and , or, not 来表示, 同时也要注意运算符的优先次序及括弧的使用。*书写要点是注意 对自然语言检索条件的正确理解。 * 示例：检索教师表中所有工资少于1500元或者工资大于2000元并且是03系的教师姓名？ 123Select Tname From Teacher WhereSalary &lt; 1500 or Salary &gt; 2000 and D# = ’03’;Select Tname From Teacher Where(Salary &lt; 1500 or Salary &gt; 2000) and D# = ’03’;&lt;正确&gt; 检索结果之去重复记录-SELECT DISTINCT FROM-WHERE 结果唯一性问题 &lt;关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组，但也允许无重复元组。&gt; 在 Table 中要求无重复元组是通过定义 Primary key 或 Unique 来保证的;而在 检索结果中要求无重复元组, 是通过 DISTINCT 保留字的使用来实现的 示例：在选课表中，检索成绩大于80分的所有学号 1234Select S# From SC Where Score &gt; 80 ; //有重复元组出现，比如一个同学两门以上课程大于80Select DISTINCT S# From SC Where Score &gt; 80; //重复元组被DISTINCT过滤掉，只保留一份 检索结果之排序-SELECT-FROM-WHERE-ORDER BY 结果排序问题 &lt;DBMS可以对检索结果进行排序，可以升序排列，也可以降序排列&gt; Select语句中结果排序是通过增加order by子句实现的 order by 列名[ [asc asc| | desc desc] 意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。 示例：按学号由小到大的顺序显示出所有学生的学号及姓名 1Select S#, SnameFrom Student Order ByS# ASC; 示例：检索002号课大于80分的所有同学学号并按成绩由高到低顺序显示 1Select S# From SC WhereC# = ‘002’and Score &gt; 80 Order ByScore DESC; 模糊查询-SELECT-FROM-WHERE * LIKE * 模糊查询问题：比如检索姓张的学生，检索张某某；这类查询问题，Select语句是通过在检 索条件中引入运算符like来表示的 含有like运算符的表达式 列名 [ not] like “ 字符串 ” 找出匹配给定字符串的字符串。其中给定字符串中可以出现%, _等匹配符 匹配规则 “ % ”匹配零个或多个字符 “ _ ”匹配任意单个字符 _ “ \\ ”转义字符，用于去掉一些特殊字符的特定含义，使其被作为普通 字符看待, 如用“%”去匹配字符%，用_ 去匹配字符_ 示例：检索所有姓张的学生学号及姓名 1Select S#, Sname From Student Where Sname Like ‘张%’; 利用SQL语言进行多表联合查询 多表联合查询 多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进 行选择运算来实现。 Select 的多表联合检索语句 123Select 列名[ [, 列名] …] From 表名1, 表名2, … &lt;表明乘积操作&gt;Where 检索条件; 相当于II列名, …, 列名( 检索条件(表名1 *表名2 *…)) 检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不 等值连接及各种 -连接 多表联合查询之连接条件 -连接之等值连接 ​ 示例：按“001”号课成绩由高到低顺序显示所有学生的姓名(二表 连接) ​ 123Select Sname From Student, SC Where Student.S# = SC.S# and SC.C# = ‘001’ Order By Score DESC; 多表连接时，如两个表的属性名相同，则需采用表名.属性名方式来限定该 属性是属于哪一个表 示例：按‘数据库’课成绩由高到低顺序显示所有同学姓名(三表连接) 12Select Sname From Student,SC,Course Where Student.S# = SC.S# and SC.C# = Course.C# and Cname= ‘数据库’ Order ByScore DESC; 表更名与表别名 重名之处理：连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名 (同一表的连接)等，因此需要使用别名以便区分 select中采用别名的方式 123Select 列名 as 列别名 [[,列名 as 列别名]…] From 表名1 as 表别名1,表名2 as 表别名2, …Where 检索条件; 上述定义中的as 可以省略 当定义了别名后，在检索条件中可以使用别名来限定属性 不等值连接 -连接之不等值连接 示例：求有薪水差额的任意两位教师 123Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary &gt; T2.Salary ; 多表联合查询训练 示例：求既学过“001”号课又学过“002”号课的所有学生的学号 12Select S1.S# From SC S1,SC S2 Where S1.S# = S2.S# and S1.C#=‘001’ and S2.C#=‘002 ; 利用SQL语言进行增-删-改 SQL - 之更新操作 元组新增Insert：新增一个或一些元组到数据库的Table中 元组更新Update:对某些元组中的某些属性值进行重新设定 元组删除Delete：删除某些元组 SQL - 之INSERT 元组新增Insert命令有两种形式 单一元组新增命令形式：插入一条指定元组值的元组 12insert into表名[(列名[，列名]…)] values (值[，值]…)； 批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元 组由子查询给出 1insertinto表名[(列名[，列名]…)] 子查询; 示例：批元组新增 新建立Table: St(S#, Sname),将检索到的满足条件的同学新增到该表中 12Select S#, SnameFrom Student Where Sname like ‘%伟’; 注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不 符合完整性约束条件，则将不会执行新增动作（将在后面介绍） 示例：新建Table: St(S#, Sname, avgScore), 将检索到的同学的平均成 绩新增到该表中 123Insert Into St(S#,Sname,avgScore) Select S#,Sname,Avg(Score) From Student, SC Where Student.S# = SC.S# Group by Student.S# ; SQL - 之DELETE SQL - 之UPDATE 12345678利用SQL语言修正与撤销数据库* SQL-DDL之撤销与修改 * 修正数据库：修正数据库的定义，主要是修正表的定义 修正表的定义 alter table tablename [add {colnamedatatype, …}] 增加新列 [drop {完整性约束名}] 删除完整性约束 [modify {colnamedatatype, …}] 修改列定义 12* 示例：在学生Student(S#,Sname,Ssex,Sage,D#,Sclass)基础上增加二列Saddr, PID Alter Table Student Add Saddrchar[40], PID char[18] ; 12* 示例：将上例表中Sname列的数据类型增加两个字符 Alter Table Student Modify Sname char(10); 12* 示例：删除学生姓名必须取唯一值的约束 Alter Table Student DropUnique(Sname) 12* 撤消基本表 drop table表名 12* 撤消数据库 drop database数据库名; 1234* SQL-DDL之数据库指定与关闭命令 指定当前数据库 use 数据库名; 12关闭当前数据库 close 数据库名; 本讲回顾第七讲—SQL语言之查询与视图第八讲—SQL语言与完整性和安全性第四章 数据库应用程序开发第九讲—嵌入式SQL语言之基本技巧第十讲—嵌入式SQL语言之动态SQL​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"前端入门","slug":"前端入门","date":"2020-04-03T09:02:21.861Z","updated":"2020-04-08T11:53:19.808Z","comments":true,"path":"2020/04/03/前端入门/","link":"","permalink":"www.aabigale.top/2020/04/03/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/","excerpt":"web前端开发最佳实践前端入门 HTML&amp;CSS 学习","text":"web前端开发最佳实践前端入门 HTML&amp;CSS 学习 第一部分 高效web前端开发综述HTML相关开发的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Java学习之基础篇","slug":"Java学习之基础篇","date":"2020-04-03T09:02:21.839Z","updated":"2020-04-23T02:03:41.735Z","comments":true,"path":"2020/04/03/Java学习之基础篇/","link":"","permalink":"www.aabigale.top/2020/04/03/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"基础篇","text":"基础篇 面向对象什么是面向对象 面向对象与面向过程 面向过程：自顶而下的编程模式 面向对象：将事务高度抽象化的编程模式 面向对象的三大基本特征 封装：所谓封装，简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。 继承：继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。 123继承方式：*实现继承：直接使用基类的属性和方法而无需额外编码的能力接口继承:仅使用属性和方法的名称、但是子类必须提供实现的能力 多态：多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。 面向对象的五大基本原则 单一职责原则：核心思想为：一个类，最好只做一件事，只有一个引起它的变化。 开放封闭原则：核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 Liskov替换原则：核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 依赖倒置原则：核心思想是依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 接口隔离原则：核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 封装、继承、多态 什么是多态 多态的概念比较简单，就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。如果按照这个概念来定义的话，那么多态应该是一种运行期的状态。 多态的必要条件：类继承或者接口实现、子类要重写父类的方法、父类的引用指向子类的对象。 具体代码体现 1234567891011121314151617181920212223242526public class Parent{ public void call(){ sout(\"I'm Parent\"); }}public class Son extends Parent{// 1.有类继承或者接口实现 public void call(){// 2.子类要重写父类的方法 sout(\"I'm son\"); }}public class Daughter extends Parent{// 1.有类继承或者接口实现 public void call(){// 2.子类要重写父类的方法 sout(\"I'm daughter\"); }}public class Test{ public static void main(String[] args){ Parent p = new Son(); //3.父类的引用指向子类的对象 Parent p1 = new Daughter(); //3.父类的引用指向子类的对象 }} 方法重写与重载 Java的继承与实现 Java的继承与组合 构造函数与默认构造函数 类变量、成员变量和局部变量 成员变量和方法作用域 平台无关性 Java如何实现的平台无关性的 JVM还支持哪些语言 值传递 值传递、引用传递 为什么说Java中只有值传递 Java基础知识基本数据类型 8种基本数据类型 整型中byte、short、int、long的取值范围 什么是浮点型？ 什么是单精度和双精度？ 为什么不能用浮点型表示金额？ 自动拆装箱 自动拆装箱 Integer的缓存机制 如何正确定义接口的返回值(boolean/Boolean)类型及命名(success/Success) String 字符串的不可变性 JDK 6和JDK 7中substring的原理及区别 replaceFirst、replaceAll、replace区别 String对“+”的重载 字符串拼接的几种方式和区别 String.valueOf和Integer.toString的区别 switch对String的支持 字符串池 常量池（运行时常量池、Class常量池） intern Java中各种关键字 transient instanceof volatile synchronized final static：用于修饰类的成员&lt;不能修饰局部变量&gt;，如成员变量、成员方法以及代码块 被static关键字修饰的成员变量、方法可以被类直接访问，不需要预先构造类的实例化对象，而不需要预先构造类的实例化对象 静态变量 在一个Java类中，可以使用static关键字来修饰成员变量，该变量称为静态变量 静态变量被所有实例共享，可以使用”类名.变量名”的形式访问 只能修饰类的成员，不能修饰局部变量 静态方法 被static关键字修饰的方法称为静态方法 使用“类名.方法名”的方式访问，也可以使用类的实例对象来访问 在一个静态方法中只能访问static修饰的成员，原因是没有被static修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象 静态代码块 在Java中，使用一对大括号包围起来的若干行代码被称为一个代码块 使用static关键字修饰的代码块称为静态代码块 当类被加载时，静态代码块会执行，并且只会执行一次&lt;因为类只加载一次&gt; 在程序中，经常使用静态代码块来对类的成员变量进行初始化 const 集合类 Collection和Collections区别 常用集合类的使用 Set和List区别？ ArrayList和LinkedList和Vector的区别 SynchronizedList和Vector的区别 Set如何保证元素不重复? HashMap、HashTable、ConcurrentHashMap区别 Java 8中Map相关的红黑树的引用背景、原理等 HashMap的容量、扩容、hash等原理 Java 8中stream相关用法 Apache集合处理工具类的使用 不同版本的JDK中HashMap的实现的区别以及原因 Arrays.asList获得的List使用时需要注意什么 Collection如何迭代 Enumeration和Iterator区别 如何在遍历的同时删除ArrayList中的元素 fail-fast 和 fail-safe CopyOnWriteArrayList ConcurrentSkipListMap 枚举 枚举的用法 枚举的实现 枚举与单例 Enum类 Java枚举如何比较 switch对枚举的支持 枚举的序列化如何实现 枚举的线程安全性问题 IO 字符流、字节流 输入流、输出流 字节流和字符流之间的相互转换 同步、异步 阻塞、非阻塞 Linux 5种IO模型 BIO、NIO和AIO的区别、三种IO的用法与原理 netty 反射 反射与工厂模式、 反射有什么作用 Class类 java.lang.reflect.* 动态代理 静态代理 动态代理 动态代理和反射的关系 动态代理的几种实现方式 AOP 序列化 什么是序列化与反序列化 Java如何实现序列化与反序列化 Serializable 和 Externalizable 有何不同 为什么序列化 serialVersionUID 为什么serialVersionUID不能随便改 transient 序列化底层原理 序列化如何破坏单例模式 protobuf 为什么说序列化并不安全 注解 元注解 自定义注解 Java中常用注解使用 注解与反射的结合 如何自定义一个注解？ Spring常用注解 泛型 什么是泛型 类型擦除 泛型带来的问题 泛型中K T V E ？ object等的含义 泛型各种用法 限定通配符和非限定通配符 上下界限定符extends 和 super List和原始类型List之间的区别? List和List之间的区别是什么? 单元测试 junit junit 和Spring 的结合 mock mockito 内存数据库（h2） 正则表达式 java.lang.util.regex.* 常用的Java工具库 commons.lang commons.*... guava-libraries netty API&amp;SPI API API和SPI的关系和区别 如何定义SPI SPI的实现原理 异常 Error和Exception 异常类型 异常相关关键字 正确处理异常 自定义异常 异常链 try-with-resources finally和return的执行顺序 时间处理 时区 冬令时和夏令时 时间戳 Java中时间API 格林威治时间 CET,UTC,GMT,CST几种常见时间的含义和关系 SimpleDateFormat的线程安全性问题 Java 8中的时间处理 如何在东八区的计算机上获取美国时间 yyyy和YYYY有什么区别？ 编码方式 什么是ASCII？ Unicode 有了Unicode为啥还需要UTF-8 UTF8、UTF16、UTF32区别 有了UTF8为什么还需要GBK？ GBK、GB2312、GB18030之间的区别 URL编解码 Big Endian和Little Endian 如何解决乱码问题 语法糖 Java中语法糖原理、解语法糖 语法糖介绍 JMS 什么是Java消息服务 JMS消息传送模型 JMX java.lang.management.* javax.management.* Java 8 lambda表达式 Stream API 时间API 阅读源代码 String Integer Long Enum BigDecimal ThreadLocal ClassLoader &amp; URLClassLoader ArrayList &amp; LinkedList HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap HashSet &amp; LinkedHashSet &amp; TreeSet Java并发编程并发与并行 什么是并发 什么是并行 并发与并行的区别 线程 线程与进程的区别 线程的实现 线程的状态 线程优先级 线程调度 多线程如何Debug 守护线程 创建线程的多种方式 继承Thread类创建线程 实现Runnable接口创建线程 通过Callable和FutureTask创建线程 通过线程池创建线程 线程池 自己设计线程池 submit() 和 execute() 线程池原理 为什么不允许使用Executors创建线程池 线程安全 什么是线程安全 多级缓存和一致性问题 CPU时间片和原子性问题 指令重排和有序性问题 线程安全和内存模型的关系 happens-before as-if-serial 锁 可重入锁 阻塞锁 乐观锁与悲观锁 数据库相关锁机制 分布式锁 无锁 CAS CAS的ABA问题 锁优化 偏向锁 轻量级锁 重量级锁 锁消除 锁粗化 自旋锁 死锁 什么是死锁 死锁的原因 如何避免死锁 写一个死锁的程序 死锁问题如何排查 synchronized synchronized是如何实现的？ synchronized和lock之间关系 不使用synchronized如何实现一个线程安全的单例 synchronized和原子性 synchronized和可见性 synchronized和有序性 volatile 编译器指令重排和CPU指令重排 volatile的实现原理 内存屏障 volatile和原子性 volatile和可见性 volatile和有序性 有了symchronized为什么还需要volatile 线程相关方法 start &amp; run sleep 和 wait notify &amp; notifyAll ThreadLocal ThreadLocal 原理 ThreadLocal 底层的数据结构 写代码来解决生产者消费者问题并发包 同步容器与并发容器 Thread Runnable Callable ReentrantLock ReentrantReadWriteLock Atomic* Semaphore CountDownLatch ConcurrentHashMap Executors document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据库作业踩的坑","slug":"数据库作业踩的坑","date":"2020-04-03T09:02:21.812Z","updated":"2020-04-03T10:59:13.317Z","comments":true,"path":"2020/04/03/数据库作业踩的坑/","link":"","permalink":"www.aabigale.top/2020/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A%E8%B8%A9%E7%9A%84%E5%9D%91/","excerpt":"第一次数据库作业踩的坑作业要求：创建数据库，并在数据库中创建数据表，用SQL命令修改表的结构，将数据插入到表中，并完成SQL查询。","text":"第一次数据库作业踩的坑作业要求：创建数据库，并在数据库中创建数据表，用SQL命令修改表的结构，将数据插入到表中，并完成SQL查询。 一、启动服务 管理员授权 Windows，不然会启动失败 用 mysql -uroot -p密码 二、创建数据表 ](1.png)&nbsp; &nbsp; ![ 最后一个字段不能加‘，’ 三、用SQL命令修改表的结构 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"计算机组成原理<一>","slug":"计算机组成原理-一","date":"2020-03-16T13:15:19.000Z","updated":"2020-04-03T10:59:13.310Z","comments":true,"path":"2020/03/16/计算机组成原理-一/","link":"","permalink":"www.aabigale.top/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80/","excerpt":"第一章 计算机系统概论","text":"第一章 计算机系统概论 1.1 计算机系统简介计算机的软硬件概念计算机系统 硬件：计算机实体 软件：具有各类特殊功能的（程序） 软件分为 系统软件： 用来管理整个计算机系统 语言处理系统 操作系统 服务性程序 数据库管理系统 网络软件 软件系统： 按任务需要编制成的各种软件 计算机系统的层次结构高级语言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机器M3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用编译程序翻译成汇编语言 汇编语言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机器M2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用汇编程序翻译成机器语言程序 操作系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机器M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用机器语言解释操作系统 机器语言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际机器M1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用微指令解释机器指令 微指令系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 微程序机器M0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由硬件直接执行微指令 计算机体系结构和计算机组成 计算机体系结构 &lt;有无乘法指令&gt; ：计算机系统属性概念性的结构与功能特性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（指令系统，数据类型，寻址技术，I/O机理） 计算机组成 &lt;如何实现乘法指令&gt; ：实现计算机体系结构所体现的属性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （具体指令的实现） 计算机的组成冯若依曼机的特点 计算机由五大件组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[],"tags":[]}