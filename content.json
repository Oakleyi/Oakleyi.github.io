{"meta":{"title":"Aabigale's blog","subtitle":"","description":"","author":"Aabigale","url":"https://oakleyi.github.io","root":"/"},"pages":[{"title":"","date":"2020-04-03T09:01:13.200Z","updated":"2020-04-03T09:01:13.200Z","comments":false,"path":"categories/index.html","permalink":"https://oakleyi.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-04-03T08:23:58.434Z","updated":"2020-04-03T08:23:58.434Z","comments":true,"path":"about/index.html","permalink":"https://oakleyi.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-04-03T08:24:18.028Z","updated":"2020-04-03T08:24:18.028Z","comments":false,"path":"tags/index.html","permalink":"https://oakleyi.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"数据库系统概述二","slug":"数据库系统概述二","date":"2020-04-10T08:26:01.025Z","updated":"2020-04-10T10:14:48.556Z","comments":true,"path":"2020/04/10/数据库系统概述二/","link":"","permalink":"https://oakleyi.github.io/2020/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E4%BA%8C/","excerpt":"","text":"数据库系统之三–数据建模与数据库设计数据建模：思想与方法为什么要数据建模和数据库设计E - R模型 – 数据建模之基本思想E - R 模型 – 表达方法之 Chen 方法E - R 模型 – 表达方法之 Crow’s foot 方法数据建模之案例讲解数据库设计中的抽象123该部分的重难点* 理解 E-R 模型进行数据模型的基本思想，熟练掌握 E-R 模型的 Crow's foot 表达方法* 熟练运用 Crow's foot 方法进行数据建模，即建模训练 12数据库设计过程数据库设计过程与设计方法E - R 图 / IDEF1X 向关系模式的转换不正确数据库设计引发的问题及其解决1234该部分重难点* 理解数据库设计的四个过程* 理解不正确数据库设计引发的问题，为数据库理论的学习奠定问题基础* 理解不正确数据库设计引发的问题，提升数据建模与数据库设计能力 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"JAVA实训作业","slug":"JAVA实训作业","date":"2020-04-09T07:59:31.340Z","updated":"2020-04-09T07:59:31.341Z","comments":true,"path":"2020/04/09/JAVA实训作业/","link":"","permalink":"https://oakleyi.github.io/2020/04/09/JAVA%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/","excerpt":"JAVA实训作业","text":"JAVA实训作业 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"前端之CSS","slug":"前端之CSS","date":"2020-04-07T06:02:28.960Z","updated":"2020-04-08T11:53:19.814Z","comments":true,"path":"2020/04/07/前端之CSS/","link":"","permalink":"https://oakleyi.github.io/2020/04/07/%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"在vscode中配置Java环境","slug":"在vscode中配置Java环境","date":"2020-04-07T05:19:19.431Z","updated":"2020-04-08T11:53:19.819Z","comments":true,"path":"2020/04/07/在vscode中配置Java环境/","link":"","permalink":"https://oakleyi.github.io/2020/04/07/%E5%9C%A8vscode%E4%B8%AD%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83/","excerpt":"在vscode中配置Java环境","text":"在vscode中配置Java环境 下载官网下载 使用配置中文 点击旁边的 Extensions 搜索框编辑 Chinese 下载 Chinese ( Simplified ) 更换主题​ 可以看自己喜好 下载关于编辑 Java 的插件​ 便于编辑而安装的插件 12345Beautify：代码高亮Terminal：直接唤起终端Project Manager：多个项目切换Auto Close Tag：标签自动闭合Eclipse Keymap：可以通过一些快捷键更方便地编写Java 配置 Java 环境而安装的插件 1234Language Support for Java(TM) by Red Hat 运行 Java 代码的Debugger for Java 调试 Java 程序Java Test Runner 测试 Java 程序Maven for Java Java环境下构建应用程序的软件 设置工作环境 点击菜单 File( 文件 ) –&gt; Save Workspace As····( 将工作区另存为)···· 将新建的 ( 文件名 ) 文件添加至工作区 新建 Java 项目 在工作区点击菜单栏 View ( 查看 ) –&gt; command Palette ( 命令面板) 输入Java，选择Java : Create Java Project，新建Java项目 在弹出的框中，选择工作空间文件夹 接着输入项目名称，回车 会自动生成一段打印hello Java代码 编译运行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"html","slug":"html","date":"2020-04-06T13:59:36.547Z","updated":"2020-04-08T11:53:19.803Z","comments":true,"path":"2020/04/06/html/","link":"","permalink":"https://oakleyi.github.io/2020/04/06/html/","excerpt":"web前端开发最佳实践","text":"web前端开发最佳实践 高效web前端开发综述web前端开发概述高效web前端开发HTML相关开发最佳实践标准的HTML代码高可读性的HTML积极拥抱HTML5 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"在hexo搭建的博客中引入图片","slug":"在hexo搭建的博客中引入图片","date":"2020-04-06T06:04:08.995Z","updated":"2020-04-06T06:04:37.536Z","comments":true,"path":"2020/04/06/在hexo搭建的博客中引入图片/","link":"","permalink":"https://oakleyi.github.io/2020/04/06/%E5%9C%A8hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87/","excerpt":"","text":"在hexo搭建的博客中引入图片 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Linux","slug":"Linux","date":"2020-04-06T03:15:10.256Z","updated":"2020-04-06T06:00:10.288Z","comments":true,"path":"2020/04/06/Linux/","link":"","permalink":"https://oakleyi.github.io/2020/04/06/Linux/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2020-04-05T13:51:43.137Z","updated":"2020-04-06T06:03:33.906Z","comments":true,"path":"2020/04/05/数据结构/","link":"","permalink":"https://oakleyi.github.io/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"数据结构","text":"数据结构 数据结构绪论基本概念与术语逻辑结构与物理结构抽象数据结构算法时间复杂度与空间复杂度线性表（list）线性表的定义线性表：零个或多个数据元素的有限序列 线性表元素的个数 n (n&gt;=0)，定义为线性表的长度，当 n=0 时，称为空表。非空表中的每个数据元素都有一个确定的位置 在较复杂的线性表中，一个数据元素可以由若干个数据项组成 学号 姓名 性别 出生年月 家庭住址 1 张三 男 1995.3 东街细想 1 号 203 室 2 李四 女 1994.8 北路 4 弄 5 号 6 室 3 王五 女 1994.12 南大道 789 号 ······ ······ ······· ······· ······· 线性表的抽象数据类型线性表的顺序存储结构 顺序存储定义 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素 示意图如下： a1 a2 ······ ai-1 ai ······ an 顺序存储方式 线性表的顺序存储的结构代码 1234567#define MAXSIZE 20 //存储空间的初始分配量typedef int ElemType;typedef struct{ ElemType daata [MAXSIZE]; int length;}SqList; 描述顺序的结构需要三个属性： 存储空间的起始位置 线性表的最大存储容量 线性表的当前长度 数据长度与线性表长度的区别 地址计算方法 存储器中每个存储单元都有自己的编号，这个标号称为地址 顺序存储结构的插入与删除 获得元素操作 插入操作 删除操作 线性表顺序存储结构的优缺点 线性表的链式存储结构单链表的读取单链表的插入与删除单链表的整表创建与删除单链表结构与顺序存储结构优缺点静态链表循环链表双向链表总结回顾栈与队列串树图查找排序 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"算法","slug":"算法","date":"2020-04-05T08:58:21.848Z","updated":"2020-04-05T10:05:18.377Z","comments":true,"path":"2020/04/05/算法/","link":"","permalink":"https://oakleyi.github.io/2020/04/05/%E7%AE%97%E6%B3%95/","excerpt":"算法","text":"算法 大整数运算该部分重难点 12* 大整数的运算的算法思想与处理技巧* 大整数进行加、减、乘、除运算的算法框架 计算n！ 当n规模较小 （n&lt;13）123456789#include &lt;stdio.h&gt;main(){ int n,t,k; scanf(\"%d\",&amp;n); t=1; //t为累乘器 for(k=1;k&lt;=n;k++) t*=k; printf(\" %d!=%ld\\n\",n,t);} 当n规模较大123456789101112131415161718192021222324252627282930#include &lt;math.h&gt;#include &lt;stdio.h&gt;int main(){ int j,k,m,n,a[100000]; long g,t; double s; printf(\"Please input an integer: \"); scanf(\"%d\",&amp;n); s=0; for (k=2;k&lt;=n;k++) s+=log10(k); m=(int)s+1;//计算n!后的位数 for (k=1;k&lt;=m;k++) a[k]=0; a[1]=1; g=0;//进位符 for (k=2;k&lt;=n;k++) for (j=1;j&lt;=m;j++) { t=a[j]*k+g; a[j]=t%10; g=t/10; } printf(\"%d!=\",n); for (k=m;k&gt;=1;k--) printf(\"%1d\",a[k]); printf(\"\\n\"); printf(\"m=%d\\n\",m);} 大整数加法 用数组储存，假定每个数组元素存储4位 核心代码： 12345678910void add(int *a, int *b, int *c){ int i; for(i = N - 1; i &gt;= 0; i--) { c[i] = a[i] + b[i] + carry; carry=c[i]/10000; c[i]=c[i]%10000; }} 大整数减法 核心代码： 1234567891011121314void sub(int *a, int *b, int *c) { int i; for(i =N- 1; i &gt;= 0; i--) { c[i] = a[i] - b[i] - borrow; if(c[i] &gt;= 0) borrow = 0; else // 借位 { c[i] = c[i] + 10000; borrow = 1;} }} 大整数乘法 大整数与整数相乘 核心代码： 123456789void mul(int *a, int b, int *c) { int i, tmp, carry = 0; for(i = N - 1; i &gt;= 0; i--) { tmp = a[i] * b + carry; c[i] = tmp % 10000; carry = tmp / 10000; } 大整数与大整数相乘 核心代码： ​ ​ 算法的概念枚举递推递归回溯法动态规划贪心算法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据库系统概述 一","slug":"数据库系统概述 一","date":"2020-04-03T09:02:21.868Z","updated":"2020-04-10T10:21:33.656Z","comments":true,"path":"2020/04/03/数据库系统概述 一/","link":"","permalink":"https://oakleyi.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%20%E4%B8%80/","excerpt":"基本知识与关系模型","text":"基本知识与关系模型 初步认识数据库系统该部分的重难点 * 一组概念的区分：数据库、数据库系统和数据库管理系统 * 熟悉“表”的相关要素及术语 * 熟悉数据库系统的构成（工作环境） * 了解数据库管理系统的功能：用户和系统角度为什么要学习数据库系统什么是数据库 数据库是电子化信息扥集合 数据库起源于规范化“表”的处理 基于“表”的数据库的影响 对“表”的抽象：理解-区分-命名-表达 数据库相互之间有关联关系的table的集合 什么是数据库系统 数据库系统的构成-概念层次 数据库 数据库管理系统 数据库应用 数据库管理员 计算机基本系统 数据库系统的构成-实例层次 什么是数据库管理系统&lt;如何利用&gt; 用户角度 * 数据库定义：用户通过**数据定义语言&lt;DDL&gt;**定义数据库中table的名称，标题 * 数据库操纵：用户通过**数据操纵语言&lt;DML&gt;**对数据库中的表进行增删改查 * 数据库控制：用户通过**数据控制语言&lt;DCL&gt;**控制数据库中数据的使用——哪些用户可以用，哪些不能用 * 数据库维护：数据库管理系统&lt;DBMS&gt;提供一系列程序给用户，从而对数据库进行维护 数据库语言 SQL语言 * 数据定义语言 * 数据操纵语言 * 数据控制语言 数据库语言与高级语言 系统角度 数据库系统的结构抽象与演变该部分的重难点 * 一组概念的区分：三级模式两层映像，物理独立性和逻辑独立性 * 一组概念的区分：数据→模式→数据模型 * 几种数据模型的差异：网状/层次模型→关系模型→oo数据模型数据库系统的标准结构数据模型数据库系统的演变与发展关系模型之基本概念该部分重难点 * 一组概念的区分：围绕关系的相关概念，如域。笛卡尔积，关系，关系模式，关键字/键/码，外码/外键，主码/主键,主属性与非属性。 * 三个完整性，参照完整性和用户自定义的完整性关系模型概述 关系模型的提出 最早由E.F.Codd在1970年提出 由表及表的处理方式中抽象出来的，进行数学化严格定义基础上，引入集合理论与逻辑学理论提出的 数据库三大经典数据模型之一 SQL语言是建立在关系模型基础上的 关系模型研究什么 形象的说，一个关系就是一个 table 关系模型就是处理 table 的，由三部分组成 描述DB各种数据的基本结构形式 描述table与table之间可能发生的各种操作 描述这些操作所应遵循的约束条件(完整性约束) 就是要学习：table如何描述，有哪些操作，结果是什么，有哪些约束 关系模型的三个要素 基本结构 基本操作 完整性约束：实体完整性，参照完整性和用户自定义的完整性 关系模型与关系数据库语言的关系 关系运算：关系代数和关系演算；关系演算：元组演算和域演算 关系代数示例：基于集合的运算 基于关系代数设计的数据库语言(ISBL)：用计算机可识别的符号表征关系代数的运算符号 元组演算：基于逻辑的运算 基于元组演算设计的数据库语言：······ 域演算示例：基于示例的运算 基于域演算设计的数据库语言：······ 为什么要学习关系模型与关系数据库语言 即将学习的内容概述 理解关系，理解如何用关系对table进行抽象或说严格定义 理解关系/表所具有的各种特征，理解关系模型 熟练掌握关系代数，元组演算和域演算 什么是关系 什么是”表” 123为什么把表称为关系？怎样严格定义一个\"表\"？\"表\"和\"关系\"有什么异同？ “表”的基本构成要素 如何严格地定义table “ 表 “的严格定义–关系？ 首先定义”列”的取值范围”域” 1234域：* 一组值的集合，这组值具有相同的数据类型 如整数的集合，，全体学生的集合* 集合中元素的个数称为域的基数 再定义” 元组 “及所有可能组合的元组：笛卡尔积 笛卡尔积：笛卡尔积是有 n 个域形成的所有可能组合的集合 笛卡尔积的基数：若 Di 的基数为 mi ，则笛卡尔积的基数即元组个数为 m1 * m2 * ··· * mn 一组域D1，D2，··· ，Dn的笛卡尔积 D1 * D2 * ····*Dn = { (d1，d2，··· ，dn) | di∈Di，i = 1，···· ，n} 笛卡尔积的每个元素( d1 , d2, … , dn ) 称作一个 *n-元组 * 笛卡尔积的的具有意义的组合称为关系 一组域D1，D2，··· ，Dn的笛卡尔积 ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"前端入门","slug":"前端入门","date":"2020-04-03T09:02:21.861Z","updated":"2020-04-08T11:53:19.808Z","comments":true,"path":"2020/04/03/前端入门/","link":"","permalink":"https://oakleyi.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/","excerpt":"web前端开发最佳实践前端入门 HTML&amp;CSS 学习","text":"web前端开发最佳实践前端入门 HTML&amp;CSS 学习 第一部分 高效web前端开发综述HTML相关开发的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Java学习","slug":"Java学习","date":"2020-04-03T09:02:21.839Z","updated":"2020-04-09T01:00:12.385Z","comments":true,"path":"2020/04/03/Java学习/","link":"","permalink":"https://oakleyi.github.io/2020/04/03/Java%E5%AD%A6%E4%B9%A0/","excerpt":"java 学习","text":"java 学习 Java 开发入门Java 编程基础面向对象 上面向对象概述 面向对象的特点 封装：面向对象的核心思想，将对象的属性和行为封装起来，不需要外界知道具体实现细节 继承：主要描述类与类之间的关系，通过继承，在无需重新编写原有类的情况下，对原有类的功能进行扩展 多态：发现在继承之后，引用相同类型的变量调用同一个方法所呈现的多种不同行为特征 Java 中的类与对象 类与对象的关系 类是对某一类事物的抽象描述，而对象用于表示现实中该类实物的个体 类用于描述多个对象的共同特征，它是对象的模板，而对象用于描述现实中的个体，它是类的实例 类的定义 类的定义格式 声明成员变量 声明成员方法 TIP： 在 Java 中，定义在类中的变量被称为成员变量，定义在方法中的变量称为局部变量 如果在某个方法中定义的局部变量与成员变量同名，此时方法中通过变量名访问到的是局部变量，而非成员变量 对象的创建与使用 对象创建的语法格式 123类名 对象名称 = new 类名()使用示例：Person p = new Person (); ​ TIP： * Java 将内存分为两种，栈内存和堆内存 * 栈内存存放基本类型的变量和对象的引用变量 ( 如Person p )，堆内存用于存放由 new 创建的对象和数组 对象成员的调用： 通过对象的引用来访问对象的所有成员 1对象引用.对象成员 直接使用创建的对象本身来引用对象成员 1new 类名().对象成员 TIP：第二种方法容易产生垃圾对象 成员变量的初始值 垃圾对象的形成 形成：当没有任何变量引用对象时，该对象将成为垃圾变量，不能再使用 对象的引用超出作用域 123456 { Person p1 = new Person(); ......} 对象的引用重新指向空地址 ( null ) 123456 { Person p2 = new Person(); ...... p2 = null; ......} ​ 说明：使用变量 p2 引用了一个Person类型的变量，接着将变量 p2 的值置为 null ，被 p2 所引用的Person 对象就会失去引用，成为垃圾对象 访问控制符 在 Java 中，针对类，成员方法提供了四种访问级别，分别是 private、default、protected 和 public 类的封装 为什么需要封装 要对成员变量的访问做出一些限定，不允许外界随意访问，这就是需要实现类的封装 如何实现封装 方法的重载和递归 方法的重载 方法的递归 构造方法 构造方法的定义 构造方法的重载 this 关键字static 关键字面向对象 下Java 中的常用类集合IO 流GUI ( 图形用户接口 )JDBC多线程网络编程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"数据库作业踩的坑","slug":"数据库作业踩的坑","date":"2020-04-03T09:02:21.812Z","updated":"2020-04-03T10:59:13.317Z","comments":true,"path":"2020/04/03/数据库作业踩的坑/","link":"","permalink":"https://oakleyi.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A%E8%B8%A9%E7%9A%84%E5%9D%91/","excerpt":"第一次数据库作业踩的坑作业要求：创建数据库，并在数据库中创建数据表，用SQL命令修改表的结构，将数据插入到表中，并完成SQL查询。","text":"第一次数据库作业踩的坑作业要求：创建数据库，并在数据库中创建数据表，用SQL命令修改表的结构，将数据插入到表中，并完成SQL查询。 一、启动服务 管理员授权 Windows，不然会启动失败 用 mysql -uroot -p密码 二、创建数据表 ](1.png)&nbsp; &nbsp; ![ 最后一个字段不能加‘，’ 三、用SQL命令修改表的结构 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"计算机组成原理<一>","slug":"计算机组成原理-一","date":"2020-03-16T13:15:19.000Z","updated":"2020-04-03T10:59:13.310Z","comments":true,"path":"2020/03/16/计算机组成原理-一/","link":"","permalink":"https://oakleyi.github.io/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80/","excerpt":"第一章 计算机系统概论","text":"第一章 计算机系统概论 1.1 计算机系统简介计算机的软硬件概念计算机系统 硬件：计算机实体 软件：具有各类特殊功能的（程序） 软件分为 系统软件： 用来管理整个计算机系统 语言处理系统 操作系统 服务性程序 数据库管理系统 网络软件 软件系统： 按任务需要编制成的各种软件 计算机系统的层次结构高级语言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机器M3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用编译程序翻译成汇编语言 汇编语言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机器M2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用汇编程序翻译成机器语言程序 操作系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机器M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用机器语言解释操作系统 机器语言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际机器M1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用微指令解释机器指令 微指令系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 微程序机器M0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由硬件直接执行微指令 计算机体系结构和计算机组成 计算机体系结构 &lt;有无乘法指令&gt; ：计算机系统属性概念性的结构与功能特性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（指令系统，数据类型，寻址技术，I/O机理） 计算机组成 &lt;如何实现乘法指令&gt; ：实现计算机体系结构所体现的属性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （具体指令的实现） 计算机的组成冯若依曼机的特点 计算机由五大件组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[],"tags":[]}